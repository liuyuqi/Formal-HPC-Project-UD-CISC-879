#include <stdio.h>
#include <stdlib.h>
#include <civlc.h>

/* ######################################
   ############ Var Decls ###############
   ######################################
*/

#define CIVL_owns(t, n, i) ((i)%(n)==(t))

#define NUM 4
#define NUMTEST 1
$input int MAX_THREADS;
$assume(MAX_THREADS <= 4 && MAX_THREADS >= 0);

float MIU;

typedef struct
{
    int node_number;
    int node_power;
    int end_tag;
    int id;
    int priority;
    int critical;
    int to_schedule;
    int scheduled;
    int dest_core;
    int start_time;
    int cost;
} node_t; /*任务节点 The data structure for task nodes.*/

node_t testnode [NUM + 1]; /*测试节点 A list of all the tasks.*/

/*DAG图的邻接矩阵  The adjacent matrix of the DAG*/
$input int dag_random[NUM][NUM];
$input int node_power[NUM];
int dag [NUM][NUM]; 

/*转换后的邻接矩阵  The adjacent matrix of the DAG after conversion*/
int dag_new [NUM+1][NUM+1]; 

/*用于任务可执行性检测的邻接矩阵 
 * The adjacent matrix of the DAG used for checking the eligibility of execution of tasks.*/
int dag_dynamic [NUM+1][NUM+1]; 

/*DAG图中边的权值矩阵  The matrix of power on edges in the DAG*/
$input int e_power_random[NUM+1][NUM+1];
int e_power [NUM+1][NUM+1]; 

/*转换后的边权值矩阵  The matrix of power on edges after transfer */
int e_power_new [NUM+1][NUM+1]; 

typedef struct
{
    int cid;
    int curr_node;
    int last_node;
    int idle; 
    int remain;
} core_t;

/*处理器核心数目 Number of cores on a processor*/
$input int NCORE;
$assume (NCORE <= 4 && NCORE > 0);

/*建立一个多核处理器 A multi-core processor */
core_t core[NCORE];

int task;
int ticks;
int need_schedule = 0;
int ready_list[NUM + 1];
int cpufree;

/*邻接表定义区*/
/*Definitions of adjacent table*/
typedef node_t vextype;
typedef struct node {
    int adjvex;
    int dur;
    struct node *next;
}edgenode;
typedef struct {
    vextype vertex;
    int id;
    edgenode *link;
}vexnode;
vexnode ga[NUM+1];


/* #########################################
   ########### Function Decls ##############
   #########################################
*/

/*Initialization of the processor model*/
void core_init ()
{
    int i;
    for (i = 0; i < NCORE; i++) {
        core[i].cid = i;
        core[i].curr_node = -1;
        core[i].last_node = -1;
        core[i].idle = 0;
        core[i].remain = 0;
    }     
}

/*Initialization of nodes (or vertices)*/
void node_init (node_t* p_node)
{
    int i = 0;
    for (i = 0; i < NUM + 1; i++) {
        p_node -> node_number = i;
        p_node -> node_power = -1;
        p_node -> end_tag = 0;
        p_node -> id = 0;
        p_node -> priority = 0;
        p_node -> critical = 0;
        p_node -> to_schedule = 0;
        p_node -> scheduled = 0;
        p_node -> dest_core = -1;
        p_node -> start_time = -1;
        p_node -> cost = 0;
        ++ p_node;
    }
    //--p_node; //This doesn't work in CIVL, why?
}

/*Initialization of the adjacent matrix of DAG*/
void dag_init () {
    int i, j;
    
    for (i = 0; i < NUM; i++) {
		for (j = 0; j < NUM; j++) 
			dag[i][j] = 0;
    } 
	for (i = 0; i <= NUM; i++) {
		for (j = 0; j <= NUM; j++) {
			dag_new[i][j] = 0;
			dag_dynamic[i][j] = 0;
		}
	}
}

/*Initialization of the matrix of the edge's power of DAG*/
void epower_init () {
    int i, j;
    for (i = 0; i <= NUM; i++) {
		for (j = 0; j <= NUM; j++) {
			e_power[i][j] = 0;    
			e_power_new[i][j] = 0;
		}
    }      
}

/*随机生成节点权值*/
/*Randomly generates the power values of vertices*/
void empower_node (node_t* p_node) {
    int i = 0;
    for (i = 0; i < NUM; i++) {
		$assume(node_power[i] > 0 && node_power[i] < 100);
		p_node -> node_power = node_power[i];
        p_node++;
    }
}

/*DAG图邻接矩阵的随机生成*/ 
/*Randomly generates the adjacent matrix of DAG*/
void dag_create () {
    int i = 0, j = 0;
    int temp_sum = 0, flag = 0; 
    for (i = 0; i < NUM; i++) {
		for (j = 0; j < NUM; j++) {
			dag[i][j] = dag_random[i][j];
		}
    }
  
    dag[0][1] = 1; /*一个必须满足的条件，第一节点必须有边*/
    /*The first node must have an edge setting off from it.*/
    dag[NUM - 2][NUM - 1] = 1;

    for (i = 0; i < NUM - 1; i++) {
        for (j = i + 1; j < NUM; j++) 
            if (i == 0 && j == 1 ) 
                dag[i][j] = 0;
		}

    /*终边约束条件判断*/ 
    /*Judges whether the final edge is legal*/
    flag = 0;
    for (j = 2; j < NUM; j++) {
        temp_sum = 0; /*计算准备*/
        for (i = 0; i < j; i++)
            temp_sum += dag[i][j]; /*循环累加*/
		$assume(temp_sum != 0);
    }
    epower_init ();

    /* 判断终点（不再发出边的点）并标记 */
    /*Judges and marks the end edges.*/
    for (i = 0; i < NUM; i++) {
        temp_sum = 0;
        for (j = 0; j < NUM; j++) {
            temp_sum += dag[i][j];
        }
        if (temp_sum == 0) {
            testnode[i].end_tag = 1;
        }
    }
}

/*Randomly produces the edges' power values of the DAG.*/
void empower_epower ()
{
    int i, j;
    for (i = 0; i < NUM; i++) { 
        for (j = 0; j < NUM; j++) {
            if (dag[i][j] != 0) {
				$assume(e_power_random[i][j] > 0 && e_power_random[i][j] < 100);
                e_power[i][j] = e_power_random[i][j] + 16;
            }
        }
    }
}

/*Make the DAG an Activity-on-Edge network*/
void dag_makeup()
{
    int i, j;
    for (i = 0; i < NUM; i++) {
        if (testnode[i].end_tag == 1)
            dag_new[i][NUM] = 1;
    }
    for (i = 0; i < NUM; i++) 
        for (j = 0; j < NUM; j++) {
            dag_new[i][j] = dag[i][j];
        }

    for (i = 0; i < NUM + 1; i++) {
        for (j = 0; j < NUM + 1; j++) {
            dag_dynamic[i][j] = dag_new[i][j];
        }
    }
}

/*Conversion of the powers on nodes to that on edges*/
void convert_dag ()
{
    int i, j;
    for (i = 0; i < NUM; i++) {
        for (j = 0; j < NUM; j++) {
            if (dag[i][j] != 0) {
                e_power_new[i][j] = e_power[i][j] * MIU + testnode[i].node_power;
            }
            else {
                e_power_new[i][j] = e_power[i][j];
            }
        }
    }
    for (i = 0; i <= NUM; i++) {
        if (testnode[i].end_tag == 1)
            e_power_new[i][NUM] = testnode[i].node_power;
    }
}

void createadjlist ()
{
    int i, j, k;
    edgenode *s;
    for (i = 0; i < NUM + 1; i++) {
        ga[i].vertex = testnode[i];
        ga[i].id = 0;
        ga[i].link = NULL;
    }

    for (i = 0; i < NUM + 1; i++) {
        for (j = 0; j < NUM + 1; j++) {
            if (dag_new[i][j] == 1) {
                ga[j].id++;
                testnode[j].id++;
                s = (edgenode*) malloc (sizeof (edgenode));
                s -> adjvex = j;
                s -> dur = e_power_new[i][j];
                s -> next = ga[i].link;
                ga[i].link = s;
            }
        }
    }
}

/*The algorithm of calculating the critical path of a DAG.*/
void critical_path ()
{
    long i, j, k, m;
    long front = -1, rear = -1;
    long tpord[NUM+1], vl[NUM+1], ve[NUM+1];
    long l[100000], e[100000];
    edgenode *p;
    for (i = 0; i < NUM+1; i++)
        ve[i] = 0;
    for (i = 0; i < NUM+1; i++) {
        if (ga[i].id == 0) {
            tpord[++rear] = i;
        }
    }
    m = 0;
    while (front != rear) {
        front ++;
        j = tpord[front];
        m++;
        p = ga[j].link;
        while (p) {
            k = p->adjvex;
            ga[k].id --;
            if (ve[j] + p->dur > ve[k])
                ve[k] = ve[j] + p->dur;
            if (ga[k].id == 0) {
                tpord[++rear] = k;
            }
            p = p -> next;
        }
    }

    if (m < NUM + 1) {
        printf("The AOE network has a cycle\n");
        return;
    }
    for (i = 0; i < NUM + 1; i++)
        vl[i] = ve[NUM];
    for (i = NUM - 1; i >= 0; i--) {
        j = tpord[i];
        p = ga[j].link;
        while (p) {
            k = p -> adjvex;
            if ( (vl[k] - p->dur) < vl[j])
                vl[j] = vl[k] - p->dur;
            p = p -> next;
        }
    }
    i = 0;
    for (j = 0; j < NUM + 1; j++) {
        p = ga[j].link;
        while (p) {
            k = p -> adjvex;
            e[++i] = ve[j];
            l[i] = vl[k] - p->dur;
            if (l[i] == e[i]) {
                testnode[j].critical = 1;
                testnode[j].priority = 2;
                testnode[k].critical = 1;
                testnode[k].priority = 2;
            }
            p = p -> next;
        }
    }
    return;
}

/*The initialization of ready list*/
void list_init ()
{
    int i;
    for (i = 0; i < NUM; i++) 
        ready_list[i] = 0;
}

/*Judge whether all tasks have been scheduled.*/
int task_not_empty ()
{
    int i;
    for (i = 0; i < NUM + 1; i++) {
        if (testnode[i].scheduled == 0)
            return 1;
    }
    return 0;
}

/*Check whether there still exist tasks with the given priority value in the ready list.*/
int exist_pri (int pri)
{
    int i;
    for (i = 0; i < NUM + 1; i++) {
        if (testnode[i].scheduled == 0 && ready_list[i] == 1 && testnode[i].priority == pri)
            return 1;
    }
    return 0;
}

/*Pick a task from the ready list with the given priority value.*/
int pick_pri (int pri)
{
    int i;
    for (i = 0; i < NUM + 1; i++) {
        if (testnode[i].scheduled == 0 && ready_list[i] == 1 && testnode[i].priority == pri)
            return i;
    }
}

/*Seek the child tasks of the task that just finished execution.
 * On found return 1, otherwise return 0.*/
int find_next_node ()
{
    int i, j, k, flagtotal;
    int last = -1;
    flagtotal = 0;
    for (i = 0; i < NCORE; i++) {
        if (core[i].idle == 1) {
            last = core[i].last_node;
        }
        else continue;

        if (ticks != 0) {
            for (j = 0; j < NUM + 1; j++) {
                if ( testnode[j].id == 0 && testnode[j].scheduled == 0) {
                    flagtotal = 1;
                    if (testnode[j].to_schedule == 0 && dag_new[last][j] == 1) {
                        if (testnode[j].priority == 2) 
                            testnode[j].priority = 3;
                        else if (testnode[j].priority == 0) 
                            testnode[j].priority = 1;
                    }
                    ready_list[j] = 1;
                    testnode[j].to_schedule = 1;
                }
            }
        }
        else {
            for (i = 0; i < NUM + 1; i++) {
                if (testnode[i].id == 0) {
                    ready_list[i] = 1;
                    testnode[i].to_schedule = 1;
                    flagtotal = 1;
                }
            }
        }
    }
    return flagtotal;
}

/*Check whether there are some cores available*/
int check_free_core ()
{
    int i;
    for (i = 0; i < NCORE; i++) {
        if (core[i].idle == 1)  {
            return 1;
        }
    }
    return 0;
}

int search_core_satisfy (int task)
{
    int i, prev_core = -1;
    for (i = 0; i < NUM + 1; i++) {
        if (dag_new[i][task] != dag_dynamic[i][task]) {
            prev_core = testnode[i].dest_core;
            if (core[prev_core].idle == 1) return prev_core;
        }   
    }
    return -1;
}

void schedule (int task)
{
    int i, j, large;
    for (i = 0; i < NCORE; i++) {
        if (core[i].idle == 1) {
            testnode[task].dest_core = i;

            testnode[task].scheduled = 1;
            testnode[task].to_schedule = 0;
            core[i].idle = 0;
            core[i].curr_node = task;
            core[i].remain = testnode[task].node_power;
            if (dag_new[core[i].last_node][task] == 0 ) {
                large = 0;
                for (j = 0; j < NUM + 1; j++) {
                    if (dag_new[j][task] == 1 && large < e_power[j][task])
                        large = e_power[j][task];
                }
                core[i].remain += large;
            }
            if (task == NUM)
                large = 0;
            testnode[task].start_time = ticks + large;
            testnode[task].cost = large;
            ready_list[task] = 0;
            break;
        }
    }
}

void schedule_to (int task, int to_core)
{
    int large, j;
    testnode[task].dest_core = to_core;

    testnode[task].scheduled = 1;
    testnode[task].to_schedule = 0;
    core[to_core].idle = 0;
    core[to_core].curr_node = task;
    core[to_core].remain = testnode[task].node_power;
    if (dag_new[core[to_core].last_node][task] == 0 ) {
        large = 0;
        for (j = 0; j < NUM + 1; j++) {
            if (dag_new[j][task] == 1 && large < e_power[j][task])
                large = e_power[j][task];
        }
        core[to_core].remain += large;
    }
    if (task == NUM)
        large = 0;
    testnode[task].start_time = ticks + large;
    testnode[task].cost = large;
    ready_list[task] = 0;
}

/*The main body of the scheduling algorithm*/
int algorithm () {
    int i, coreid;
    int des_core;
    for (ticks = 0; task_not_empty(); ticks++) {
        for (coreid = 0; coreid < NCORE; coreid++) {
            if (core[coreid].idle == 0 && core[coreid].remain > 0)
                core[coreid].remain--;
            if (core[coreid].remain == 0 && core[coreid].idle == 0) {
                core[coreid].idle = 1;
                core[coreid].last_node = core[coreid].curr_node;
                core[coreid].curr_node = -1;
                /*如果之前有任务执行，则将之前任务发出的有向边去掉*/
                /*If there was some tasks executing on the core, then eliminate the directed edge 
                 * from the previous task (vertex).*/
                if (core[coreid].last_node != -1) {
                    for (i = 0; i < NUM + 1; i++) {
                        if (dag_new[core[coreid].last_node][i] == 1) {
                            dag_dynamic [core[coreid].last_node][i] = 0; 
                            testnode[i].id--;
                        } 
                    }
                } 
            }
        }

        need_schedule = 0;
        need_schedule = find_next_node ();
        if (need_schedule) {
            des_core = -1;
            while ( (check_free_core () != 0) && (exist_pri (3) != 0) ) {
                task = pick_pri (3);
                des_core = -1;
                des_core = search_core_satisfy (task);
                if (des_core > -1)  schedule_to (task, des_core);
                else  schedule (task);
            }
            while ( check_free_core () && exist_pri (2) ) {
                task = pick_pri (2);
                schedule (task);
            }
            while ( check_free_core () && exist_pri (1) ) {
                task = pick_pri (1);
                des_core = -1;
                des_core = search_core_satisfy (task);
                if (des_core > -1)  schedule_to (task, des_core);
                else  schedule (task);
            }
            while ( check_free_core () && exist_pri (0) ) {
                task = pick_pri (0);
                schedule (task);
            }
        }
    }
    int large = 0;
    return ticks;
}

void node_recover () 
{
    int i = 0;
    node_t *p_node = &testnode[0];
    for (i = 0; i < NUM + 1; i++) {
        p_node -> priority = 0;
        p_node -> critical = 0;
        p_node -> to_schedule = 0;
        p_node -> scheduled = 0;
        p_node -> dest_core = -1;
        p_node -> start_time = -1;
        p_node -> cost = 0;
        ++ p_node;
    }
    //-- p_node;
}

void random_test()
{
	int i, j;
    for (i = 0; i < NUM; i++) {
		for (j = 0; j < NUM; j++) {
			$assume(dag_random[i][j] == 0 || dag_random[i][j] == 1);
		}
    }
}

void main()
{
    int test, result_idx, var;
    int result[101];
    long result_total_seq[101], result_total_par[101];
    for (result_idx = 0; result_idx <= 100; result_idx++) {
        result_total_seq[result_idx] = 0;
        result_total_par[result_idx] = 0;
    }
    for (test = 0; test < NUMTEST; test ++) {
        for (result_idx = 0; result_idx <= 100; result_idx++) {
            result[result_idx] = 0;
        }
        printf("test %d started\n", test);
        node_t* p_node = &testnode[0]; /*节点指针 pointer to a vertex (node)*/

        /*Initialization stage*/
        node_init (p_node); /*节点的初始化 Initialization on nodes*/
        dag_init (); /*DAG图邻接矩阵的初始化 init on adjacent matrix of DAG*/ 
        epower_init (); /*DAG图边权值矩阵的初始化 init on edges' power matrix of DAG*/
        core_init ();	/*处理器模型的初始化 init on the processor model */

        /*Stage of random number production*/
        p_node = &testnode[0];
        empower_node (p_node);/*随机生成节点权值 Randomly produces the power of nodes*/
        dag_create ();/*DAG图邻接矩阵的随机生成 Randomly produces the adjacent matrix of the DAG.*/ 
        empower_epower ();/*DAG图边权值的随机生成 Randomly produces the power of edges.*/
        dag_makeup (); /*将DAG补全成AOE网络 Convert the DAG to Activity-on-Edge network*/
        
        /*Function Decls of seq and par*/
        void iteration(int var)
        {
			int result_private = result[var];
        	MIU = (float)var / 100.0;
			core_init ();
			node_recover ();
			list_init ();
			convert_dag (); /*DAG图权值的变换 Transfer the power from vertices to edges*/
			createadjlist ();
			critical_path ();  /*AOE关键路径的求解 Solving the critical path.*/
			result_private = algorithm ();
			result_total_par[var] += result_private;
        }
        
        void run_seq()
        {
			for (var = 0; var <= 100; var++) {
				MIU = (float)var / 100.0;
				core_init ();
				node_recover ();
				list_init ();
				convert_dag (); /*DAG图权值的变换 Transfer the power from vertices to edges*/
				createadjlist ();
				critical_path ();  /*AOE关键路径的求解 Solving the critical path.*/
				result[var] = algorithm ();
				result_total_seq[var] += result[var];
			}
        }
        
        void run_par(int tid, int nthreads)
        {
			for (var = 0; var <= 100; var++) {
				if (CIVL_owns(tid, nthreads, var))
					iteration(var);
			}
        }
        
        /*Stage of implementing scheduling algorithm*/
        run_seq();
        
        int nthreads = $choose_int(MAX_THREADS);
        $proc threads[nthreads];
        for (int tid = 0; tid < nthreads; tid++) {
			threads[tid] = $spawn run_par(tid, nthreads);
        }
        for (int tid = 0; tid < nthreads; tid++)
			$wait(threads[tid]);
		for (var = 0; var <= 100; var++)
			$assert(result_total_seq[var] == result_total_par[var]);
    }
}

